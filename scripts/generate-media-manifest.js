import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { encodeMediaPath } from '../media-utils.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.resolve(__dirname, '..');
const OUTPUT_FILE = path.join(ROOT_DIR, 'slideshow-media.js');

const MEDIA_DIRECTORIES = ['images', 'video'];
const ALLOWED_EXTENSIONS = new Set([
  'jpg',
  'jpeg',
  'png',
  'gif',
  'svg',
  'webp',
  'avif',
  'mp4',
  'webm',
  'ogg',
  'mov'
]);

async function collectMediaFiles() {
  const results = [];

  for (const directory of MEDIA_DIRECTORIES) {
    const absoluteDir = path.join(ROOT_DIR, directory);
    let entries;

    try {
      entries = await fs.readdir(absoluteDir, { withFileTypes: true });
    } catch (error) {
      if (error.code === 'ENOENT') {
        continue;
      }
      throw error;
    }

    for (const entry of entries) {
      const entryPath = path.join(absoluteDir, entry.name);
      if (entry.isDirectory()) {
        const nested = await collectNestedMediaFiles(entryPath);
        results.push(...nested);
        continue;
      }

      if (isAllowedMediaFile(entry.name)) {
        results.push(formatRelativePath(entryPath));
      }
    }
  }

  return results.sort((a, b) => a.localeCompare(b));
}

async function collectNestedMediaFiles(directoryPath) {
  const stack = [directoryPath];
  const found = [];

  while (stack.length > 0) {
    const currentDir = stack.pop();
    let entries;

    try {
      entries = await fs.readdir(currentDir, { withFileTypes: true });
    } catch (error) {
      if (error.code === 'ENOENT') {
        continue;
      }
      throw error;
    }

    for (const entry of entries) {
      const entryPath = path.join(currentDir, entry.name);
      if (entry.isDirectory()) {
        stack.push(entryPath);
        continue;
      }

      if (isAllowedMediaFile(entry.name)) {
        found.push(formatRelativePath(entryPath));
      }
    }
  }

  return found;
}

function isAllowedMediaFile(fileName) {
  const extension = fileName.split('.').pop();
  if (!extension) {
    return false;
  }

  return ALLOWED_EXTENSIONS.has(extension.toLowerCase());
}

function formatRelativePath(absolutePath) {
  const relative = path.relative(ROOT_DIR, absolutePath).split(path.sep).join('/');
  const prefixed = `./${relative}`;
  return encodeMediaPath(prefixed);
}

async function writeManifestFile(mediaFiles) {
  const header = `// This file is auto-generated by scripts/generate-media-manifest.js\n`;
  const body = `const mediaFilesList = ${JSON.stringify(mediaFiles, null, 2)};\n\n`;
  const exportLine = 'export const mediaFiles = Object.freeze(mediaFilesList);\n';
  await fs.writeFile(OUTPUT_FILE, `${header}${body}${exportLine}`);
}

async function main() {
  const mediaFiles = await collectMediaFiles();
  await writeManifestFile(mediaFiles);
  console.log(`Generated slideshow-media.js with ${mediaFiles.length} entries.`);
}

if (process.argv[1] && path.resolve(process.argv[1]) === __filename) {
  main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
  });
}
